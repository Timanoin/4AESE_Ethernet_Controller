Interface entre la machine et le réseau
On ne s'occupe aps de l'interface physique
Couche liaison de données : MAC
2 éléments principaux : émetteur et récepteur

Commencer par l'émetteur puis le récepteur
f=100MHz:
- Regarder le chemin critique
- tests en simulation et en implémentation
- taille vs fpga

Reception de données : format trame ethernet ( 64 octets au total minimum, 4500 octets max)
X Préambule : 		   7 octets en alternance 1-0 qui fixe la fréquence (couche physique : on ne le considère pas)
- SFD : 			   1 octet "10101011" qui indique le début d'une trame
- Adresse de destination : 6 octets 
- Adresse de la source :   6 octets
~ Longueur et type :       2 octets (à ne pas utiliser au début, à part pour une version avancée)
- Données et padding :     0 to inf 
X Sequence de vérification : 4 octets (on ne le considère pas)
- Delimiteur de fin de trame : 1 octet "01010100"

Améliorations :
- champ longueur
- vérification taillemin et taillemax
- FCS
- Réémission

P=logique positive, N=logique inverse

RECEPTION :
- RBYTEP : sortie = impulsion binaire qui indique la réception d'un nouvel octet de donnée (écriture dans RDATAO)
- RCLEANP : sortie = implusion binaire qui indique une erreur sur la réception (trame trop petite, trop longue, si on est aps le destinataire,etc)
- RCNVGP : sortie = niveau binaire pour indiquer la réception (passe à 1 au SFD, tant qu'on recoit de la donnée, passe à 0 au EFD)
- RDATZ0[7:0] : sortie = octet (vect binaire) de donnée à transmettre à la couche supérieure (LLC)
- RDONEP : sortie = impulsion binaire qui indique la fin de réception d'une frame (bonne ou pas)
- RENABP : entrée = niveau binaire qui indique que le récepteur peut fonctionner
- RSMATIP : sortie = niveau binaire qui passe haut si la trame en traitement nous est bien destinée
- RSTARTP : sortie = impulsion binaire à la fin du SFD (au début d'une trame)
- RDATAI[7:0] : entrée = vecteur d'un octet qui fait le lien entre la couche physique et la couche mac

8 tics d'horloge pour recevoir un nouvel octet (diviseur d'horloge ????????)
si l'adresse ne nous est aps destinée: fin de frame
On écrit l'adresse source dans RDATAO
transmission des données dans RDATAO
On n'envoie pas le EFD dans RDATAO

TRANSMISSION :
- TABORTP : entrée = arrêt de la transmission (problème ou collision) => envoyer 4 octets de 1-0 alternés
- TAVAILP : entrée = trame prête à la transmission
- TDATAI[7:0]: entrée = octet à transmettre
- TDATAO[7:0] : sortie = octet à envoyer à la couche physique
- TDONEP : sortie = impulsion binaire qui indique la fin de transmission
- TFINISHP : entrée = impulsion(?) arrête la transmission
- TLASTP : entrée = impulsion binaire qui indique que l'entrée est le dernier octet de donnée
- TREADDP : sortie = impulsion qui prévient la couche llc qu'on a envoyé l'octet
- TRNSMTP : sortie = niveau qui indique qu'on est en transmission
- TSTARTP : sortie = impulsion qui indique le début de la transmission

à nous de créer le SFD et le EFD
transmettre l'adresse dest
écrire notre adresse (source) à nous

COLLISIONS :
- TSOCOLP : sortie = niveau qui indique une collision (en fonction de RCVNGP et TRNSMTP gestion des collision : attaque de RENABP et TABORTP)

AUTRES :
- CLK : clock au bit
- RESETN : entrée = à low, rien ne fonctionne (remise à 0)
- NOADDRI[47:0] : entrée = adresse du matériel (émission->source/réception->destination)


